https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488007&idx=1&sn=9d0dcfdf475168d26a5a4bd6fcd3505d&chksm=fd9cb918caeb300e1c8844583db5c5318a89e60d8d552747ff8c2256910d32acd9013c93058f&token=211780171&lang=zh_CN#rd
邻接表
这也是一种在图论中十分常见的存图方式，与数组存储单链表的实现一致（头插法）。
这种存图方式又叫「链式前向星存图」。
适用于边数较少的「稀疏图」使用，当边数量接近点的数量，即  时，可定义为「稀疏图」。

int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M];
int idx;

void add(int a, int b, int c) {
    e[idx] = b;
    ne[idx] = he[a];
    he[a] = idx;
    w[idx] = c;
    idx++;
}

首先 idx 是用来对边进行编号的，然后对存图用到的几个数组作简单解释：

he 数组：存储是某个节点所对应的边的集合（链表）的头结点(he[2]等于节点2第一条边的编号)；
e  数组：由于访问某一条边指向的节点；(e[1]等于编号为1的边指向的节点)；
ne 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边；(ne[2]等于编号为2的边在尾节点上的下一条边的编号)；
w  数组：用于记录某条边的权重为多少。(w[1]等于编号为1的边的权重)；

在每次新增一条边的信息时（假设为E1（1，2，2）），如果这条边的尾节点已经有其他边（假设为E2（1，3，2））了，那么就会让E1的下一条边指向E2，然后
E1作为1的头节点，这样可以通过E1找到E2以及剩下的边，类似于链表。

因此当我们想要遍历所有由 a 点发出的边时，可以使用如下方式：

for (int i = he[a]; i != -1; i = ne[i]) {
    int b = e[i], c = w[i]; // 存在由 a 指向 b 的边，权重为 c
}


